# 编程小结
- 解决前面的在Init()函数在运行时出现Segmentation fault。
具体链接看这里：
https://zhidao.baidu.com/question/1430070924967188019.html

- **Init() 函数的两种 正确写法：**

**①带形参**
```
 void Init_1(LinkStack *top)    //形参必须是指向指针的指针
{
if((*top=(LinkStack)malloc(sizeof(LStackNode)))==NULL)
exit(-1);
(*top)->next=NULL;
}

//在main函数
int main(){
	.....
	LinkStack top1 = NULL;
	Init1_LinkStack(&top1);
	.....
}
```
**②不带形参**---带返回值

```
LinkStack Init_2()              //不带形参 避免使用指向指针的指针，代码可读性高
{
LinkStack top；

 if((top=(LinkStack)malloc(sizeof(LStackNode)))==NULL)
        return NULL;

	top->next=NULL;
return top;

}
```
- ** Init()出现 段错误的写法：**
```
void Init_3(LinkStack top)     //我也是这样写的！！！
{
	if((top=(LinkStack)malloc(sizeof(LStackNode)))==NULL)
		exit(-1);
	top->next=NULL;
}
```
**为什么会错误？**
**解析**
**①** 要注意的是此时确实已经给top分配了内存，但是这段内存是给形参的，也就是函数修改的是形参的内容，而不是实参的内容，因此你分配的内存无法通过实参访问，因为实参根本就没有被更改。
**②** 如果用LinkStack *类型的话，这时的形参是指向指针的指针，所以分配内存的时候，改变的是形参指向的内存内的值，而不会改变形参的值，因此可以通过实参访问你分配的内存，相当于两重传递。
**③** 对于这种错误的初始化方法Init_3() 补救方法：
```
LinkedList head;
head = Init_3(head);
```
这时，通过函数返回值 赋给head，使得head的值更新。

- Stack中的TOP栈顶指针、Bottom栈底指针。
 栈顶指针SP始终指向栈顶元素（即首元节点），所以可以把单链表的头节点 看做SP指针，其指向第一个节点。栈底指针则指向单链表的尾端节点。


