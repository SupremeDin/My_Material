编程小结
=========
> **1.由于指针作形参类型不符**

eg：在子函数定义时，其形参为（LinkedList head），那么在main函数中进行函数调用时实参是什么样子的呢？？？？

           子函数定义：   void Traverse_LinkedList(LinkedList head)
          main()调用：   LinkedList head_;
                         Traverse_LinkedList(head_);

但刚开始没搞懂，在main()中使用Traverse \_ LinkedList(&head\_)，这是错误的，因为由子函数定义知：函数形参的类型为 struct \* ,然后若将主函数实参写为(&head_),这意味着函数的形参类型为 struct \*\*

> **2 不了解形参的传递实质，导致出现segement fault**

错误再现：

                    LinkedList head = NULL;
                    Create_Head_LinkedList(head,5);   //正确操作：head = Create_Head_LinkedList(head,5); 
                    printf("%d",head->next->data);      //segement fault! 
1.当函数形参为一般变量时，在参数传递时：传递其拷贝值（实现自动保护），相当于开辟了一段新内存，原变量的内存未改动，所以原变量值不变。
2.当函数形参为指针变量时，在传递参数时：传递的是变量的地址（实参为地址），所以相当于在同一块内存上进行操作。

刚开始以为:不需要将create()函数的返回值赋值给head指针，以为其在函数内部就已经指向了新生成的节点。但是事实证明，不赋值的话，head仍然是NULL。这是因为？？？

> **3 当函数参数为 struct、array时，一般用指针作形参来传递同一块内存上进行操作。**

这是因为，当用其本身作形参时（语法上没问题，是正确的），进行的是值传递，也就是重新开辟了内存，复制了原来的struct，这多么浪费内存啊～～

> **4 if...else if...else语法运用错了！**

错误再现：

                        if(i < 1 ||i > length)
		                printf("insert position illegal!\n");
	                    if(i == 1){                     // error!!!此处应该为else if
		                       s->next = head->next;
		                       head->next = s;
	                    }
	                    else{
							   LinkedList p = FindKth_LinkedList(head,i-1);
		                       s->next = p->next;
		                       p->next = s;
	                    }

> **5.求数组长度**

记住在用sizeof(array)/sizeof(array[0])来求数组长度的时候，只能在定义数组的地方才能求出正确的值！
若在子函数中传递数组名，是得不到正确结果的；在64位机中，假设是int型数组sizeof(array)/sizeof(int) = 2，这是因为数组名传递到子函数中 只会被当做一个（首元素）地址，在64位机中用8 bytes来表示，而int类型4 bytes 所以其值等于2.