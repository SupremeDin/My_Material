编程小结
=======
- Warning：由于头文件中struct的定义而产生的指针类型不明确

```
warning: assignment from incompatible pointer type [-Wincompatible-pointer-types]
lq->rear->next = nodePtr;
```
于是我们来看一下，next、nodePtr的指针类型分别是什么！
来到头文件中的定义：（未修改之前）
```
“linkQueue.h”
//定义结点结构（单链表的结点）------QNode
typedef struct $${
        ElemType data;
        struct QNode* next;
}QNode,*QueuePtr;

//定义队列的链式结构----linkQueue
//其由front、rear 两个(指向QNode)指针构成队列的链式结构
typedef struct $${
        QueuePtr front;
        QueuePtr rear;
}linkQueue;
```
- 注意$$的位置
	由于省略掉struct的真实名字（QNode），在struct体中定义的next指针就找不到QNode是什么，从而导致指针类型不明确。
- 解决：在struct之后紧跟其真实名字！养成良好的编程习惯。

- **循环队列 创建时候的问题：段错误**

```
	错误再现：
	//创建循环队列
	//操作：1.分配数组的空间，其大小正好为需要遍历的二叉树的节点数目（当所需空间已知时候，推荐使用循环队列） 
	//     2.在这里我们规定：front为队列中第一个元素的下标，rear为队列中最后一个元素的下一个位置的下标。

pQueue Create_Queue(int Max){
        pQueue q ;
        q->data = (queueElemType *)malloc(Max * sizeof(queueElemType));
        q->front = 0;
        q->rear = 0; //初始化时候front = rear：表示此时候队列是控队列
        q->Maxsize = Max;
        return q;
        
子函数定义如上，在main()中调用时如下：
	pQueue q；
	q = Create_Queue(7);
	
	编译通过，但是./a.out出现 Segmentation fault (core dumped)	
}

```
上面 循环队列（数组实现）为什么会出现段错误？
```
	受到其他案例启发，作如下修改后，运行成功。
	pQueue Create_Queue(int Max){
        Queue queue;      //************ modify here ************
        pQueue q = &queue;  //******** modify here ************
        q->data = (queueElemType *)malloc(Max * sizeof(queueElemType));
        q->front = 0;
        q->rear = 0; //初始化时候front = rear：表示此时候队列是控队列
        q->Maxsize = Max;
        return q;
}

```
	