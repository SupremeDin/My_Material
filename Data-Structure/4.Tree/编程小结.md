编程小结
===

### **编程技巧：哨兵思想（Sentinel）**
	“利用哨兵来进行顺序查找时令人眼前一亮的”
	常用来作为比较：1.比大小---->快排  2.比相等与否---->判等
- 在void Create_BTree1(BTree *tree)中，采用中序递归的方法去建立二叉树。

```
错误再现：
 void Create_BTree1(BTree *tree)
	{
        int temp;
        scanf("%d",&temp);
        //每次进来之后就分配Node。
        //*tree = (BTNode *)malloc(sizeof(BTNode));  //放在这里是正确的
        if( temp != 0 && *tree){
                printf("left child:");
                Create_BTree1(&(*tree)->left);
                printf("left----done!\n");
                
                printf("parent : %d",temp);
                *tree = (BTNode *)malloc(sizeof(BTNode)); //关键是这里出了错
                (*tree)->data = temp;
                printf("\t parent done!\n");
                
                
                printf("right child:");
                Create_BTree1(&(*tree)->right);
                printf("right----done!\n");
        }
        else
                *tree = NULL;
        printf("--------------------\n");
        return;
}
```
原错误代码如上：运行./a.out后，显示错误如下：
> 
$ ./a.out 
5
left child:6
left child:9
Segmentation fault (core dumped)

原因分析：段错误基本上是指针，地址分配不当构成的。代码中用malloc分配节点的空间是放在了left child（递归创建的后面），也就是说，执行上面的递归之后需要用到的地址空间并没有实现分配好，而是在后面分配的，故引起段错误。

-------

###  **递归 Recursion Algorithm 与尾递归**

> 一看就懂的博客  https://blog.csdn.net/zcyzsy/article/details/77151709

#### **递归 ：Stack耗用多**
	
	【定义】递归，就是在运行的过程中调用自己。
	构成递归需具备的条件：
	1. 子问题须与原始问题为同样的事，且更为简单；
	2. 不能无限制地调用本身，须有个出口，化简为非递归状况处理。
		必须提供一个出口：编程上多用 if...else...
	
	原理：
	1. 当C程序中调用了一个函数时，栈中会分配一块空间来保存与这个调用相关的信息，每一个调用都被当作是活跃的。栈上的那块存储空间称为活跃记录或者栈帧
	2. 栈帧由5个区域组成：输入参数、返回值空间、计算表达式时用到的临时存储空间、函数调用时保存的状态信息以及输出参数。
	3. 栈是用来存储函数调用信息的绝好方案，然而栈也有一些缺点：
		3.1 栈维护了每个函数调用的信息直到函数返回后才释放，这需要占用相当大的空间，尤其是在程序中使用了许多的递归调用的情况下。
		3.2 因为有大量的信息需要保存和恢复，因此生成和销毁活跃记录需要消耗一定的时间。我们需要考虑采用迭代的方案。
		3.3递归过的压栈和出栈，时间和空间都有很大的消耗，

#### **尾递归：不压栈的递归，编译器自动优化** 

	 原理：
	 当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。
	 
### 怎样区分 递归、尾递归？

	相对于递归而言：尾递归满足：
	1. 当递归调用是整个函数体中最后执行的语句
	2. 它的返回值不属于表达式的一部分【借助博客中求阶乘的 递归、尾递归 两种实现方式，发现函数的return值是明显不同的，递归实现的返回值是表达式的一部分，而尾递归的返回值是独立的，尾递归没有回归过程】
	
	尾递归的重要特点：在回归过程中不用做任何操作【这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码】

#### 递归编程出现错误：没有定义出口！！！！

```
错误再现：
void PreOrderTraverse(BTree tree){
        printf("  %d",tree->data);
        PreOrderTraverse(tree->left);
        PreOrderTraverse(tree->right);
        return;
}
```
出错原因，没有给出口。

#### 层序遍历 编程时出现的问题（主要是队列操作的问题）
问题1：队列满？？？
	7个二叉树节点，分配7个元素空间的队列，不刚刚好吗？？？
	**用的是循环队列！！！！有效空间是`n-1`**
问题2：大概描述一下：
	由于在EnQueue()中对入队元素没有进行判断，使得NULL也入队了。这就导致了，后面在level()层序遍历的程序里面要去访问NULL的left，right这必然会出现 段错误啊！！！！
	
#### 从编译角度讲，`尾递归`都可以用`迭代/循环`来代替
1.递归的效率不高
2.`尾递归`实为`不入栈的递归`，即其不需要用堆栈去保存上一次的现场，递归的函数名出现在程序的最后return处。


#### 被include多次
一个工程有多个文件，例如 main.c , list.h , list.c 等多个文件，一定要注意，include头文件，或者其他c文件时候，只需要在main.c中include一次即可（多次include会引起冲突。）





