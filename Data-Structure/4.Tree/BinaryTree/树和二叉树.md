树和二叉树
======
- **树**
	1. 是一类**非线性数据结构**（层次结构）。
	(前面的`SQlist`，`Stack`，`Queue`都是线性结构)
	
> 
	1. 数据管理的 3大基本操作：add、delete、search
	2. 查找Searching：静态查找、动态查找
	   静态查找
	   几种静态查找表的(最大)时间复杂度 [不是平均复杂度]
	
	

||查找|插入|删除|
|:--:|:--:|:--:|:--:|
|无序顺序表|**\*顺序查找：O(n)**|O(1)|O(n)|
|有序顺序表|**\*二分查找：O(lgn)**|O(n)|O(n)|
无序线性链表|O(n)|O(1)|O(1)|
|有序线性链表|O(n)|O(1)|O(1)

>
	上表解释：
	1. 只要是链表，插入、删除 操作都是O(1)
	2. 顺序表的插入、删除操作：需要移动元素，故时间复杂度O(n)
	
- **由上面的 二叉查找 形成了对Tree的直观形象**

----
- **二叉树**
	1. 二叉树是 树形结构里面最重要的！由一般树的`左儿子-右兄弟表示法`，再顺时针旋转45度，可以从‘树--->二叉树’。
	2. 特殊二叉树：斜二叉树（单链表）、满二叉树、完全二叉树（\*）。
	1. 二叉树重要性质：n0 = n2 +1 （证明：把树 从上往下、从下往上看，寻找节点跟边的关）
	1. 二叉树ADT：（主要看常用的操作集）
	1. 二叉树的存储结构：
	5.1 顺序存储（类似`层序遍历`），对于 完全二叉树 而言是有好的，一般二叉树会浪费空间
	5.2 **链式存储 【又称之为`二叉链表`】每个BTnode 含有两个指针域：left、right**
	1. 二叉树的遍历：（可用`递归` 和 `非递归` 两种编程方法实现，以二叉树的链式存储为存储结构）
	**先序、中序、后序 ：遍历时候经历的节点路线是一样的，只是访问各节点的时间不同**
	这就导致了3种遍历算法在代码层面上具有很大的相似性。
	6.2 `递归遍历`：（见递归算法recursion的讲解）
	6.3 `非递归遍历`：实现的基本思路是 使用堆栈。（非递归遍历较为麻烦，暂且着重讨论一下：）
```
void pre_traverse(BTree pTree)  
{  
    PSTACK stack = create_stack();  //创建一个空栈  
    BTree node_pop;                 //用来保存出栈节点，出栈节点有啥作用？没用到啊
    BTree pCur = pTree;             //定义用来指向当前访问的节点的指针  
  
    //直到当前节点pCur为NULL且栈空时，循环结束  
    while(pCur || !is_empty(stack))  
    {  
        //从根节点开始，输出当前节点，并将其入栈，  
        //同时置其左孩子为当前节点，直至其没有左孩子，及当前节点为NULL  
        printf("%c ", pCur->data);  
        push_stack(stack,pCur);  
        pCur = pCur->pLchild;  
        //如果当前节点pCur为NULL且栈不空，则将栈顶节点出栈，  
        //同时置其右孩子为当前节点,循环判断，直至pCur不为空  
        while(!pCur && !is_empty(stack))  
        {  
            pCur = getTop(stack);  
            pop_stack(stack,&node_pop);  
            pCur = pCur->pRchild;              
        }  
    }  
}
大体思路是这样的：
1.定义一个指向当前TNode的指针pCur！
  pCur:非空往左走，空往右走。
2.遍历（大循环）的终止条件：（pCur=NULL 并且 Stack=空）
3.pCur的值来自两个方面：
	3.1 当pCur非空：pCur = pCur->pLchild;
	3.2 当pCur 空：pCur从栈顶SP取值。
4.由以上先序非递归算法步骤，最后的pCur走的路径的终点不是 根节点。
  （但是后序遍历的话就一定要回到 根节点？）事实证明，后序遍历的非递归实现跟前序、中序不太一样。
5.需要用到的函数：
	5.1 create_stack();  //创建一个空栈
	5.2 getTop(stack);  // 获取当前栈顶指针SP的地址并将其赋值给pCur
	5.3 push_stack(stack,pCur); //
	5.4 pop_stack(stack,&node_pop); // 5.2跟5.4实为一个函数，目的就是对pCur进行重定向，并且pop，所以可以在pop函数中返回出栈节点的地址，并将这个地址赋值给pCur。
6.由此可见，Stack在非递归遍历的作用：
	重定向pCur的值，以期pCur能够遍历完整二叉树
7.Stack中存储的是（BTNode的地址）或（指向二叉树节点的指针），两者实为一回事儿。
8.对于非递归遍历而言：先序，中序代码是类似的；后序遍历略有不同（有点难？）。
9.编程链接：[非递归遍历](https://blog.csdn.net/lafengxiaoyu/article/details/53218104) 
```
- 二叉树的递归/非递归 都**需要使用堆栈**。


- 遍历的核心问题是 **二维结构的线性化**
	1.从parent节点访问其left、right节点
	2.访问left儿子后，其right儿子怎么办？
		此时就需要一个存储结构来暂时保存不访问的节点。
		存储结构：stack？queue？
		在非递归遍历时，我们用stack来暂时保存节点
		在层序遍历中，我们用queue来保存节点
		
- 二叉树的层序遍历
	1.采用队列实现。
	2.层序遍历的基本过程为：
	 2.1根节点入队
	 2.2进入大循环：节点出队、访问节点、其左右儿子入队。